################
辅助函数
################

.. contents::
    :local:
    :depth: 2

*****************
什么是辅助函数?
*****************

顾名思义,辅助函数可以帮助你完成任务。每个 helper 文件只是某个特定类别的函数集合。有 **URL 辅助函数**,可以帮助创建链接,有 **表单辅助函数** 可以帮助创建表单元素,**文本辅助函数** 执行各种文本格式化,**Cookie 辅助函数** 设置和读取cookie,**文件辅助函数** 帮助处理文件等等。

与 CodeIgniter 中的大多数其他系统不同,辅助函数不是面向对象的格式。它们是简单的程序性函数。每个辅助函数执行一个特定的任务,不依赖于其他函数。

CodeIgniter 默认不加载辅助文件,所以使用辅助函数的第一步是加载它。一旦加载,它就可以在你的 :doc:`控制器 <../incoming/controllers>` 和 :doc:`视图 <../outgoing/views>` 中全局使用。

辅助函数通常存储在  **system/Helpers** 或 **app/Helpers** 目录中。 CodeIgniter 会首先在你的 **app/Helpers** 目录中查找。如果目录不存在或指定的 helper 不在那里,CI 将改为在全局的 **system/Helpers** 目录中查找。

****************
加载辅助函数
****************

.. note:: URL 辅助函数总是加载的,所以你不需要自己加载它。

使用以下方法加载辅助文件非常简单:

.. literalinclude:: helpers/001.php

其中 ``name`` 是辅助函数的文件名,不含 “**.php**” 文件扩展名或 “**_helper**” 部分。

.. important:: CodeIgniter 辅助函数文件名全部小写。因此,在区分大小写的文件系统(如 Linux)上,``helper('Name')`` 将无法工作。

例如,要加载名为 **cookie_helper.php** 的 **Cookie 辅助函数** 文件,你会这样做:

.. literalinclude:: helpers/002.php

.. note:: 上面的辅助函数加载方法不返回值,所以不要试图将其分配给变量。只按显示的方式使用它。

加载多个辅助函数
========================

如果你需要一次加载多个辅助函数,可以传递一个文件名数组,它们都会被加载:

.. literalinclude:: helpers/003.php

在控制器中加载
=======================

可以在控制器方法中的任何位置加载辅助函数(甚至在视图文件中,尽管这不是一个好的实践),只要在使用它之前加载它即可。

你可以在控制器构造函数中加载辅助函数,以使它们自动在任何方法中可用,或者你可以在需要它的特定方法中加载辅助函数。

但是,如果你想在控制器构造函数中加载,则可以改用 Controller 中的 ``$helpers`` 属性。参见 :ref:`控制器 <controllers-helpers>`。

.. _helpers-loading-from-non-standard-locations:

从非标准位置加载
===================================

只要通过 :doc:`自动加载器配置文件 <../concepts/autoloader>` 中的 PSR-4 部分设置的命名空间可以找到该路径,就可以从 **app/Helpers** 和 **system/Helpers** 之外的目录加载辅助函数。你会使用可以找到它们的命名空间前缀辅助函数的名称。在该命名空间目录内,加载器期望它存在于名为 **Helpers** 的子目录中。一个示例将有助于理解这一点。

对于此示例,假设我们已经将所有与博客相关的代码分组到自己的命名空间 ``Example\Blog`` 中。文件存在于我们的服务器上的 **Modules/Blog/** 中。因此,我们会将博客模块的辅助函数文件放在 **Modules/Blog/Helpers/** 中。**blog_helper** 文件将位于 **Modules/Blog/Helpers/blog_helper.php**。在我们的控制器中,我们可以使用以下命令加载辅助函数:

.. literalinclude:: helpers/004.php

你也可以使用以下方式:

.. literalinclude:: helpers/007.php

.. note:: 以这种方式加载的文件中的函数并不是真正的命名空间化的。命名空间只是用作方便定位文件的一种方式。

.. _auto-loading-helpers:

自动加载辅助函数
====================

.. versionadded:: 4.3.0

如果你发现整个应用程序都需要一个特定的辅助函数,你可以告诉 CodeIgniter 在系统初始化期间自动加载它。
这是通过打开 **app/Config/Autoload.php** 文件,并将辅助函数添加到 ``$helpers`` 属性来完成的。

**************
使用辅助函数
**************

一旦你加载了包含要使用的函数的辅助文件,你就可以像调用标准 PHP 函数一样调用它。

例如,要在视图文件中使用 :php:func:`anchor()` 函数创建一个链接,你会这样做:

.. literalinclude:: helpers/005.php

其中 “Click Here” 是链接的名称,“blog/comments” 是你想要链接到的控制器/方法的 URI。

*******************
“扩展”辅助函数
*******************

要“扩展”辅助函数,请在 **app/Helpers/** 文件夹中创建一个与现有辅助函数相同名称的文件。

如果你只需要为现有辅助函数添加一些功能 - 可能添加一个或两个函数,或者更改某个特定辅助函数的工作方式 - 那么用你的版本完全替换整个辅助函数有点过度设计。在这种情况下,最好只是“扩展”辅助函数。

.. note:: 这里“扩展”一词使用很宽松,因为辅助函数是程序性的和离散的,在传统意义上无法扩展。在底层,这为你提供了添加或替换辅助函数提供的函数的能力。

例如,要扩展原生的 **Array 辅助函数**,你需要创建一个名为 **app/Helpers/array_helper.php** 的文件,并添加或覆盖函数:

.. literalinclude:: helpers/006.php

.. important:: 不要指定命名空间 ``App\Helpers``。

:php:func:`helper()` 函数将扫描 **app/Config/Autoload.php** 中定义的所有 PSR-4 命名空间,并加载所有匹配的同名辅助函数。这允许加载任何模块的辅助函数,以及你专门为此应用程序创建的任何辅助函数。加载顺序如下:

1. app/Helpers - 这里加载的文件总是先加载。
2. {namespace}/Helpers - 所有命名空间按定义的顺序循环。
3. system/Helpers - 基础文件最后加载。

*********
接下来呢?
*********

在目录中,你会找到所有可用 :doc:`辅助函数 <../helpers/index>` 的列表。浏览每个函数以查看它们的作用。
